---
title: 高级发布机制
slug: advanced-publications
date: 0013/01/02
number: 13.5
points: 10
sidebar: true
photoUrl: http://www.flickr.com/photos/ikewinski/8390558986/
photoAuthor: Mike Lewinski
contents: 学习更多处理发布机制的高级方法。| 了解发布/订阅模型可以得到怎样的弹性机制。
paragraphs: 36
---


目前你应该对发布/订阅交互模式有一个不错的掌握了。接下来让我们学习一些高级的方法。

### 多次发布一个集合

在我们前面的章节 [发布和订阅](/chapter/publications-and-subscriptions/), 我们看到了一些通用的发布和订阅模式，并学习了使用 `_publishCursor` 函数实现我们现在的网站。

首先，让我们回忆一下 `_publishCursor` 函数为我们做了什么: 它取得满足当前游标(cursor)的所有文档(document),并将它们推送到客户端的*同名*集合中。注意这个名字和_发布(publication)_的名字是不相关的。

这意味着我们可以有_多个订阅_连接客户端与服务端的任何版本的集合。

我们已经在之前的章节使用过这种模式[分页](/chapter/pagination/),在我们发布一个除当前显示帖子之外的分页的子集时。

另一个相似的例子是发布一个大文档集合的*概要*,也就是一个项目的全部细节:

<%= diagram "doublecollection", "Publishing a collection twice", "pull-center" %>

~~~js
Meteor.publish('allPosts', function() {
  return Posts.find({}, {fields: {title: true, author: true}});
});

Meteor.publish('postDetail', function(postId) {
  return Posts.find(postId);
});
~~~

客户端现在订阅这两个发布，`'帖子'`集合从这个两个发布获得数据:从第一个订阅中获得标题和用户名列表，从第二个订阅中获得帖子的具体内容。

你可能已经意识到 `postDetail` 发布的帖子在 `allPosts` 中也发布了(尽管只有它们属性的子集)。无论怎样，Meteor会通过合并字段来保证没有重复的帖子。

这很好，因为当我们显示帖子摘要列表时，数据对象中刚好有需要显示的数据。然而，当我们显示一个单独的帖子，我们有需要显示的所有数据。当然，我们需要注意在这种情况下客户端并没有所有帖子的全部字段 -- 这是个常见问题！

注意你并没有改变文档属性的限制。你可以方便地在两个发布中发布同样的属性，但是内容排序不同。

~~~js
Meteor.publish('newPosts', function(limit) {
  return Posts.find({}, {sort: {submitted: -1}, limit: limit});
});

Meteor.publish('bestPosts', function(limit) {
  return Posts.find({}, {sort: {votes: -1, submitted: -1}, limit: limit});
});
~~~
<%= caption "server/publications.js" %>

### 多次订阅同一个发布

我们已经看到了如何多次发布统一集合。由此你可以得到另一个相似的模式:创建一个发布，多次*订阅*它。

在Microscope中，我们多次订阅 `posts` 发布，Iron Router 为我们建立和取消每次订阅。然而我们也可以自己*同时*订阅多次。

例如，我们想要同时载入最新的和最佳的帖子到内存:

<%= diagram "subscribetwice", "Subscribing twice to one publication", "pull-center" %>

我们建立一个发布:

~~~js
Meteor.publish('posts', function(options) {
  return Posts.find({}, options);
});
~~~

并且我们多次订阅这个发布。事实上或多或少的在Microscope里这样做了：

~~~js
Meteor.subscribe('posts', {submitted: -1, limit: 10});
Meteor.subscribe('posts', {baseScore: -1, submitted: -1, limit: 10});
~~~

这里发生了什么?每个浏览器开启了*两个*不同的订阅，每个订阅连接到*同个*服务端的发布。

每个订阅提供了不同的参数给发布，但从根本上，每次从服务器端`帖子`集合中获得一个(不同的)文档集合放入客户端集合。

你甚至可以用*同样的参数*订阅相同的发布两次。这也许没有什么用处，但这种灵活性也许将来某天会有用!

### Multiple Collections in a Single Subscription

Unlike more traditional relational databses like MySQL which make use of *joins*, NoSQL databases like Mongo are all about *denormalizing* and *embedding*. Let's see how that works in the context of Meteor.

Let's look at a concrete example. We've added comments to our posts, and so far, we've been happy to only publish the comments on the single post that the user is looking at.

However, suppose we wanted to show comments on *all* the posts on the front page (keeping in mind that these posts will change as we paginate through them). This use case presents a good reason for embedding comments in posts, and in fact is what pushed us to denormalize comment *counts*.

Of course we could always just embed comments in posts, getting rid of the `Comments` collection altogether. But like we previously saw in the *Denormalization* chapter, by doing so we would be losing some of the extra benefits of working with separate collections.

But it turns out there's a trick involving subscriptions that makes it possible to embed our comments while preserving separate collections.

Let's suppose that along with our front-page list of posts, we want to subscribe to a list of the top 2 comments for each post.

It would be difficult to accomplish this with an independent comments publication, especially if the list of posts was limited in some way (say, the 10 most recent). We'd have to write a publication that looked something like this:

<%= diagram "multiplecollections", "Two collections in one subscription", "pull-center" %>

~~~js
Meteor.publish('topComments', function(topPostIds) {
  return Comments.find({postId: topPostIds});
});
~~~

This would be a problem from a performance standpoint, as the publication would need to get torn down and re-established each time the list of `topPostIds` changed.

There is a way around this though. We just use the fact that we can not only have more than one *publication* per *collection*, but we can also have more than one *collection* per *publication*:

~~~js
Meteor.publish('topPosts', function(limit) {
  var sub = this, commentHandles = [], postHandle = null;

  // send over the top two comments attached to a single post
  function publishPostComments(postId) {
    var commentsCursor = Comments.find({postId: postId}, {limit: 2});
    commentHandles[postId] =
      Mongo.Collection._publishCursor(commentsCursor, sub, 'comments');
  }

  postHandle = Posts.find({}, {limit: limit}).observeChanges({
    added: function(id, post) {
      publishPostComments(id);
      sub.added('posts', id, post);
    },
    changed: function(id, fields) {
      sub.changed('posts', id, fields);
    },
    removed: function(id) {
      // stop observing changes on the post's comments
      commentHandles[id] && commentHandles[id].stop();
      // delete the post
      sub.removed('posts', id);
    }
  });

  sub.ready();

  // make sure we clean everything up (note `_publishCursor`
  //   does this for us with the comment observers)
  sub.onStop(function() { postHandle.stop(); });
});
~~~

Note that we aren't returning anything in this publication, as we manually send messages to the `sub` ourselves (via `.added()` and friends). So we don't need to ask `_publishCursor` to do it for us by returning a cursor.

Now, every time we publish a post we also automatically publish the top two comments attached to it. And all with a single subscription call!

Although Meteor doesn't make this approach very straightforward yet, you can also look into the `publish-with-relations` package on Atmosphere, which aims to make this pattern easier to use.

### Linking different collections

What else can our newfound knowledge of the flexibility of subscriptions give us? Well, if we don't use `_publishCursor`, we don't need to follow the constraint that the source collection on the server needs to have the same name as the target collection on the client.

<%= diagram "linkedcollections", "One collection for two subscriptions", "pull-center" %>

One reason why we would want to do this is *Single Table Inheritance*.

Suppose that we wanted to reference various types of objects from our posts, each of which stored common fields but also differed slightly in content. For example, we could be building a Tumblr-like blogging engine where each post possesses the usual ID, timestamp, and title; but in addition can also feature an image, video, link, or just text.

We could store all these objects in a single `'resources'` collection, using a `type` attribute to indicate which sort of object they are. (`video`, `image`, `link`, etc.).

And although we'd have a single `Resources` collection on the server, we could  transform that single collection into multiple `Videos`, `Images`, etc. collections on the client with the following bit of magic:

~~~js
  Meteor.publish('videos', function() {
    var sub = this;

    var videosCursor = Resources.find({type: 'video'});
    Mongo.Collection._publishCursor(videosCursor, sub, 'videos');

    // _publishCursor doesn't call this for us in case we do this more than once.
    sub.ready();
  });
~~~

We are telling `_publishCursor` to publish our videos (just like returning) the cursor would do, but rather than publish to the `resources` collection on the client, instead we are publishing from `'resources'` to `'videos'`.

Another similiar idea is to use publish to a client side collection where there's *no server side collection at all!* For instance, you might grab the data from a 3rd party service, and publish them into a client-side collection.

Thanks to the flexibility of the publish API, the possibilities are endless.
